package br.ufpe.cin.nlp.sentence;

import java.io.File;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;

import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import br.ufpe.cin.util.db.PooledHSQLDBConnectionFactory;

public class TrigramDBManager {
	
	// private Integer freqLock = new Integer(0); //was used by deprecated code
	
	private Integer trigramLock = new Integer(0);
	
	GenericObjectPool<Connection> connectionPool;
	
	private static final File dbPath = new File("/dev/shm/trigramDB/trigramDB");
	private static final String dbUser = "SA";
	private static final String dbPass = "";
	

	public TrigramDBManager() throws Exception {
		GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
		poolConfig.setBlockWhenExhausted(true);
		final int numProcs = Runtime.getRuntime().availableProcessors();
		poolConfig.setMaxIdle(numProcs);
		poolConfig.setMaxTotal(numProcs);
		this.connectionPool = new GenericObjectPool<Connection>(new PooledHSQLDBConnectionFactory(dbPath, dbUser, dbPass), poolConfig);
		createTables();
		
	}
	
	private void createTables() throws Exception {
		String dropOld = "DROP SCHEMA PUBLIC CASCADE";
		String genInfoTable = "CREATE TABLE corpusInfo ( " +
				"id INTEGER PRIMARY KEY, " +
				"numDocs BIGINT NOT NULL, " +
				"totalTokens BIGINT NOT NULL " +
				")";
		String wordsTable = "CREATE CACHED TABLE words ( " +
				"id INTEGER PRIMARY KEY, " +
				"word VARCHAR(80) NOT NULL, " +
				"wordCount REAL NOT NULL, " +
				"wordDocCount BIGINT NOT NULL, " +
				"CONSTRAINT uniqWord UNIQUE(word)" +
				")";
		String freqIndex = "CREATE INDEX DocCountIndex ON words(wordDocCount)";
		String trigramsTable = "CREATE CACHED TABLE trigramFirstTwo ( " +
				"id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0, INCREMENT BY 1) PRIMARY KEY, " +
				"fstword INTEGER NOT NULL, "	+
				"sndword INTEGER NOT NULL, "	+
				"CONSTRAINT fkFirstWord FOREIGN KEY (fstword) REFERENCES words(id), " +
				"CONSTRAINT fkSndWord FOREIGN KEY (sndword) REFERENCES words(id), " +
				"CONSTRAINT uniqFstSndComb UNIQUE(fstword, sndword)" +
				")";
		String trigramLast = "CREATE CACHED TABLE trigramLast ( " +
				"id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0, INCREMENT BY 1) PRIMARY KEY, " +
				"firsttwo INTEGER NOT NULL, " +
				"lastword INTEGER NOT NULL, " +
				"occurr INTEGER NOT NULL, " +
				"CONSTRAINT fkFirsttwo FOREIGN KEY (firsttwo) REFERENCES trigramFirstTwo(id) ON DELETE CASCADE, " +
				"CONSTRAINT fkLastword FOREIGN KEY (lastword) REFERENCES words(id)," +
				"CONSTRAINT uniqTrigram UNIQUE(firsttwo, lastword)" +
				")";
		String[] createTableCommands = {dropOld, genInfoTable, wordsTable, trigramsTable, trigramLast, freqIndex};
		Connection conn = this.connectionPool.borrowObject();
		try {
			Statement stmt = conn.createStatement();
			for (int i = 0; i < createTableCommands.length; i++) {
				stmt.executeUpdate(createTableCommands[i]);
			}
			stmt.close();
		} finally {
			this.connectionPool.returnObject(conn);
		}
	}
	
	/*
	@Deprecated //FIXME broken
	public void updateWordOcurr(String word) throws SQLException {
		final String queryWord = "SELECT id, freq FROM words WHERE word = ?";
		final String updateFreq = "UPDATE words SET freq = ? WHERE id = ?";
		final String insertFreq = "INSERT INTO words (word, freq) VALUES (?, ?)";
		synchronized(freqLock) {
			PreparedStatement pstmt = conn1.prepareStatement(queryWord);
			pstmt.setString(1, word);
			ResultSet rset = pstmt.executeQuery();
			if (rset.next()) {
				final int id = rset.getInt(1);
				double freq = rset.getDouble(2);
				freq += 1.0;
				pstmt.close();
				pstmt = conn1.prepareStatement(updateFreq);
				pstmt.setDouble(1, freq);
				pstmt.setInt(2, id);
				pstmt.executeUpdate();
				pstmt.close();
				pstmt = null;
			} else {
				pstmt.close();
				pstmt = conn1.prepareStatement(insertFreq);
				pstmt.setString(1, word);
				pstmt.setDouble(2, 1.0);
				pstmt.executeUpdate();
				pstmt.close();
				pstmt = null;
			}
		}
	}
	*/
	
	public int addTrigram(int[] idGrams) throws Exception {
		assert idGrams.length == 3;
		final String queryFirstTwoExist = "SELECT id from trigramFirstTwo WHERE fstword = ? AND sndword = ?";
		final String insertFirstTwo = "INSERT INTO trigramFirstTwo (fstword, sndword) VALUES (?, ?)";
		
		synchronized (trigramLock) {
			Connection conn = this.connectionPool.borrowObject();
			try {
				PreparedStatement pstmt = conn.prepareStatement(queryFirstTwoExist);
				pstmt.setInt(1, idGrams[0]);
				pstmt.setInt(2, idGrams[1]);
				ResultSet rset = pstmt.executeQuery();
				int firstTwoId;
				if (rset.next()) {
					firstTwoId = rset.getInt(1);
					pstmt.close();
					pstmt = null;
				} else {
					pstmt.close();
					pstmt = conn.prepareStatement(insertFirstTwo, Statement.RETURN_GENERATED_KEYS);
					pstmt.setInt(1, idGrams[0]);
					pstmt.setInt(2, idGrams[1]);
					pstmt.executeUpdate();
					rset = pstmt.getGeneratedKeys();
					rset.next();
					firstTwoId = rset.getInt(1);
					pstmt.close();
					pstmt = null;
				}
				final String queryTrigram = "SELECT id, occurr FROM trigramLast WHERE firsttwo = ? AND lastword = ?";
				pstmt = conn.prepareStatement(queryTrigram);
				pstmt.setInt(1, firstTwoId);
				pstmt.setInt(2, idGrams[2]);
				rset = pstmt.executeQuery();
				final int occurr;
				if (rset.next()) {
					//has trigram, update occurr
					final String updateOccur = "UPDATE trigramLast SET occurr = ? WHERE id = ?";
					
					final int id = rset.getInt(1);
					occurr = rset.getInt(2) + 1;
					pstmt.close();
					pstmt = conn.prepareStatement(updateOccur);
					pstmt.setInt(1, occurr);
					pstmt.setInt(2, id);
					pstmt.executeUpdate();
					pstmt.close();
					pstmt = null;
				} else {
					final String insertTrigram = "INSERT INTO trigramLast (firsttwo, lastword, occurr) VALUES (?, ?, ?)";
					pstmt.close();
					pstmt = conn.prepareStatement(insertTrigram);
					pstmt.setInt(1, firstTwoId);
					pstmt.setInt(2, idGrams[2]);
					occurr = 1;
					pstmt.setInt(3, occurr);
					pstmt.executeUpdate();
					pstmt.close();
					pstmt = null;
				}
				return occurr;
			} finally {
				this.connectionPool.returnObject(conn);
			}
		}
	}
	
	public void close() {
		this.connectionPool.clear();
	}
	
	@Override
	protected void finalize() throws Throwable {
		super.finalize();
		this.close();
	}

	public void insertWordFrequency(int index, String word, double frequency, int docCount) throws Exception {
		final String insertFreq = "INSERT INTO words (id, word, wordCount, wordDocCount) VALUES (?, ?, ?, ?)";
		Connection conn = this.connectionPool.borrowObject();
		try {
			PreparedStatement pstmt = conn.prepareStatement(insertFreq);
			pstmt.setInt(1, index);
			pstmt.setString(2, word);
			pstmt.setDouble(3, frequency);
			pstmt.setLong(4, docCount);
			pstmt.executeUpdate();
			pstmt.close();
		} finally {
			this.connectionPool.returnObject(conn);
		}
	}

	public void insertGeneralInfo(int totalNumberOfDocs, long totalWordOccurrences) throws Exception {
		final String insertGenInfo = "INSERT INTO corpusInfo (id, numDocs, totalTokens) VALUES (?, ?, ?)";
		Connection conn = this.connectionPool.borrowObject();
		try {
			PreparedStatement pstmt = conn.prepareStatement(insertGenInfo);
			pstmt.setInt(1, 0);
			pstmt.setLong(2, totalNumberOfDocs);
			pstmt.setLong(3, totalWordOccurrences);
		} finally {
			this.connectionPool.returnObject(conn);
		}
	}
}
